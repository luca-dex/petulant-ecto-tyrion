\documentclass[11pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}

\usepackage{amsmath, amsfonts, amssymb}
\usepackage{graphicx}

\usepackage{parskip}

\author{L. De Sano, A. Donizetti, M. Scotti}
\title{Risoluzione di sistemi lineari sparsi \\con Python e Scipy}
\date{Maggio 2014}


\begin{document}
\maketitle
\begin{abstract}
Descriviamo l'utilizzo del linguaggio Python e di un ambiente di librerie denominato \emph{Scipy} per la risoluzione di sistemi lineari sparsi.
\end{abstract}

\section*{Python e Scipy}

In questa sezione diamo una descrizione del linguaggio di programmazione (Python) e dell'ambiente di librerie per il calcolo scientifico (Scipy) utilizzati nel progetto. Dettagliamo i criteri che hanno orientato la scelta, e spieghiamo brevemente come e perché Python e Scipy soddisfano effettivamente le nostre aspettative.

\subsection*{Python}

Python\footnote{\texttt{python.org}} è un linguaggio di programmazione \emph{open-source}, \emph{general-purpose} e di alto livello che supporta vari paradigmi di programmazione (tra cui imperativo, ad oggetti, funzionale). E\` un linguaggio dinamico e con una sintassi che facilita la scrittura di codice mantenibile e leggibile, è considerato particolarmente adatto per lo sviluppo rapido di applicazioni software e/o di scripting.

Nella scelta del linguaggio di programmazione da utilizzare per l'esecuzione dei test proposti sui sistemi lineari sparsi, ci siamo basati sulle seguenti caratteristiche:
\begin{itemize}
	\item \textbf{rapidità di sviluppo}: il linguaggio deve permettere lo sviluppo rapido di codice anche poco strutturato (in totale qualche centinaio di righe di codice che effettuano il setup delle librerie ed eseguono una serie di test);
	\item \textbf{maturità del linguaggio}: il linguaggio deve essere diffuso, ben supportato su varie piattaforme di computazione, semplice da installare e ben documentato;
	\item \textbf{disponibilità di librerie}: il linguaggio deve essere dotato di una libreria per il calcolo scientifico (e in particolar modo per la manipolazione di matrici sparse) ben testata e ben documentata (sia a livello di documentazione primaria, sia per quanto riguarda la disponibilità di materiale esterno come tutorial e discussioni riguardo problemi e modalità d'utilizzo della libreria stessa);
	\item \textbf{performances}: il linguaggio (e le sue librerie) devono fornire gli strumenti adatti ad eseguire computazioni di natura pesantamente numerica in maniera efficiente (ovvero il linguaggio di per sé non deve astrarre troppo dall'architettura hardware del calcolatore, o qualora lo faccia deve fornire un'interfaccia che consenta la chiamata di procedure di basso livello, ad esempio scritte in altri linguaggi di programmazione);
\end{itemize}

Considerato il requisito sulla rapidità di sviluppo, abbiamo deciso di escludere in prima battuta l'utilizzo di alcuni dei linguaggi compilati tipicamente usati in ambito computazione scientifica (C, C++, FORTRAN), e di orientarci sulla categoria dei linguaggi dinamici (in genere molto più versatili e adatti all'ambito scripting e software prototyping). Poiché tutti e tre i componenti del gruppo avevano esperienza pregressa in fatto di sviluppo Python, è stato deciso di prendere in considerazione l'utilizzo di tale linguaggio.

Per quanto riguarda la maturità dell'ambiente di programmazione è indubbio che il Python soddisfi il requisito sopracitato: il linguaggio è diffusamente utilizzato, ben documentato, ben supportato e attivamente sviluppato. Decisamente ben pubblicizzata è anche l'esistenza di un ambiente di programmazione adatto alla computazione scientifica (Scipy), su cui ci soffermeremo nella sezione successiva. L'interprete originale (CPython) e le librerie standard sono preinstallati sulla maggior parte dei sistemi Linux e OS X, ed è disponibile un installer per i sistemi Windows. L'installazione di librerie aggiuntive (distribuite separatamente da quella standard) è lievemente più complicata, soprattutto nel caso di codice che ha anche dipendenze esterne (come nel caso di Scipy).

L'ultimo punto è l'unico che avrebbe potuto rivelarsi problematico: è noto come i linguaggi dinamici (solitamente interpretati, come appunto il Python) tipicamente hanno la peggio nel confronto con i linguaggi compilati in termini \emph{performances}\footnote{Questo è ancora più evidente per codice dinamico sviluppato rapidamente e senza che la questione performances sia stata considerata accuratamente durante lo fase di progettazione}. Per questo motivo, nella scelta delle librerie esterne da utilizzarsi per la manipolazione di matrici, abbiamo avuto cura di utilizzare un ambiente di programmazione (Scipy, appunto) che non fosse stato completamente scritto in Python puro, ma che mettesse invece a disposizione un'interfaccia Python per l'utilizzo di librerie \emph{high-performances} scritte in altri linguaggi, e opportunamente racchiuse in \emph{wrappers} Python. Questo ci ha infine consentito di utilizzare a nostro vantaggio la rapidità di sviluppo fornita da un linguaggio dinamico senza tuttavia dover rinunciare ad ottenere ottime \emph{performaces} sulle computazioni numeriche effettuate durante i test.


\subsection*{Scipy}
Scipy\footnote{\texttt{scipy.org}} è un ecosistema di librerie \emph{open-source} pensate per la scrittura di codice nell'ambito della computazione scientifica. Consiste in una serie di pacchetti (strettamente integrati tra loro) che implementano funzionalità di manipolazione array multidimensionali (Numpy), calcolo numeroco ed ottimizzazione (Scipy-library), realizzazione di grafici e schemi (Matplotlib) e computazioni simboliche (Sympy).

Come anticipato nella sezione precedente, per eseguire computazioni numericamente intensive scritte in Python a livelli di \emph{performances} accettabili è necessario delegare la maggior parte delle operazioni di basso livello a librerie specializzate sviluppate in linguaggi più adatti a tale compito. Scipy non fa eccezione e, pur mantenendo un'interfaccia di alto livello, esegue buona parte delle computazioni numeriche affidandosi a del codice macchina che gira al di fuori dell'interprete Python scritto in \texttt{C} e in \texttt{FORTRAN}. 

Per quanto riguarda lo stato dell'arte della libreria è possibile apprendere da sito ufficiale del progetto che il tutto è in pieno sviluppo, ad esempio l'ultimo rilascio di Scipy e Numpy è del 3 maggio 2014.

Tutto lo sviluppo delle librerie è effettuato su github e questo permette una grandissima flessibilità di sviluppo in quanto sono centinaia gli sviluppatori che sottomettono al gruppo di lavoro i propri miglioramenti e questo permette al progetto di crescere rapidamente integrando funzionalità sempre nuove. Ovviamente come succede per ogni software, soprattutto per quelli opensource sono presenti alcuni bug e alcune funzioni sono solo prototipate ma non implementate.

La sezione dove sono presenti le discussioni degli sviluppatori è molto ricca ed è facile trovare risposte ad eventuali problemi incontrati durante lo sviluppo del codice. In caso di segnalazione di problematiche nuove la comunity è molto attenta e rapida nel dare una risposta alla questione posta.

Tutte le librerie che compongono scipy hanno una milestone molto ricca che prevede l'introduzione di sempre nuove funzionalità di analisi e simulazione oltre al miglioramento e alla risoluzione delle problematiche aperte.

\subsection*{Scipy per la soluzione di sistemi sparsi}

Per la risoluzione dei sistemi lineari sparsi, sono stati utilizzati il modulo \texttt{scipy.sparse} per l'importazione e la manipolazione di matrici sparse e il sottomodulo \texttt{scipy.sparse.linalg} che contiene i risolutori diretti e iterativi specializzati per operare su matrici sparse. Entrambi i moduli utilizzano a loro volta il pacchetto \texttt{numpy}.

Per la manipolazione di matrici, \texttt{numpy} utilizza prevalentemente codice C e chiamate a ATLAS\footnote{Implementazione \emph{open-source} di BLAS} e LAPACK\footnote{Linear Algebra PACKage, scritto in FORTRAN}, mentre il modulo \texttt{scipy.sparse.linalg} utilizza UMFPACK\footnote{Unsymmetric multifrontal sparse LU factorization package (\texttt{cise.ufl.edu/research/sparse/umfpack}), scritto in C e chiamato tra l'altro dall'operatore $\setminus$ di Matlab quando le matrici sono sparse} e SuperLU\footnote{Supernodal LU (\texttt{crd-legacy.lbl.gov/$\sim$xiaoye/SuperLU})} per i risolutori diretti. I risolutori iterativi sono implementati in Python puro, ma possono venire precondizionati tramite fattorizzazioni LU parziali calcolate da SuperLU, e risultano quindi in ogni caso abbastanza veloci.

Proprio a causa di queste dipendenze esterne, l'installazione di Scipy è maggiormente soggetta a problemi rispetto a quanto accade di solito con altre librerie Python. Nonostante l'ambiente Scipy sia ben strutturato a livello di pacchetti e supportato, la modalità di installazione più semplice prevede l'utilizzo almeno di un \emph{package-manager} di sistema (tipicamente presenti su sistemi Linux, vedi aptitude), che si occupa anche di installare e linkare pacchetti esterni (implementazioni BLAS, UMFPACK e altri). La presenza di queste librerie è fondamentale per il funzionamento di Scipy, e non è del tutto banale configurare correttamente il sistema per usarle nel caso si scelga di effettuare un'installazione manuale.

Le dipendenze esterne vanno anche a compromettere leggermente la portabilità del linguaggio: se è quasi garantito che del codice che utilizza solamente la libreria standard sia in grado di girare su sistemi diversi, abbiamo riscontrato invece delle inconsistenze (delle quali parleremo in seguito) nell'esecuzione su calcolatori differenti di test che utilizzano codice Scipy. 


% descrizione generale
% cosa contiene e cosa fa
% come si installa
% come è documentato
% il progetto è attivo [dati committs / mailing lists]


\section*{Risoluzione di sistemi sparsi}

\subsection*{Lettura dei file e memorizzazione}
% performance parser hand-made vs mmread integrato
% problema conversione formato MatrixMarket
% script di conversione con tempi di esecuzione

\subsection*{Metodi diretti}
% metodi disponibile
% tempi di esecuzione
% errori sulla soluzione

\subsection*{Metodi iterativi}
% metodi disponibili
% tempi di esecuzione
% errori nella soluzione

\subsection*{Problematiche incontrate}
% matrice quasi singolare 

\subsection*{Conclusione}
% conclusione

\end{document}